<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Storage Pipeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* slate-900 */
        }
        .orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .pipeline-card {
            background-color: rgba(30, 41, 59, 0.5); /* slate-800 with opacity */
            border: 1px solid rgba(51, 65, 85, 0.7); /* slate-700 with opacity */
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .pipeline-card:hover {
            border-color: rgba(56, 189, 248, 0.5); /* sky-400 with opacity */
        }
        .step-output {
            background-color: #1e293b; /* slate-800 */
            border: 1px solid #334155; /* slate-700 */
        }
        .neon-text {
            color: #7dd3fc; /* sky-300 */
            text-shadow: 0 0 5px rgba(14, 165, 233, 0.7), 
                         0 0 10px rgba(14, 165, 233, 0.7), 
                         0 0 20px rgba(14, 165, 233, 0.5);
        }
        .btn-neon {
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(14, 165, 233, 0.6), 0 0 10px rgba(14, 165, 233, 0.4);
        }
        .btn-neon:hover {
            box-shadow: 0 0 10px rgba(14, 165, 233, 1), 0 0 20px rgba(14, 165, 233, 0.8), 0 0 30px rgba(14, 165, 233, 0.6);
            transform: translateY(-2px);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.8s ease-out forwards;
        }
        .fade-in-delay-1 { animation-delay: 0.2s; }
        .fade-in-delay-2 { animation-delay: 0.4s; }
        .fade-in-delay-3 { animation-delay: 0.6s; }
        .fade-in-delay-4 { animation-delay: 0.8s; }
        .fade-in-delay-5 { animation-delay: 1.0s; }
    </style>
</head>
<body class="bg-slate-900 text-gray-200">
    <div class="container mx-auto px-4 py-12 md:py-20">
        <header class="text-center mb-20">
            <h1 class="orbitron text-4xl md:text-6xl font-bold text-white mb-4">
                DNA Storage Pipeline
            </h1>
            <p class="text-lg md:text-xl text-sky-300 max-w-3xl mx-auto">
                Une simulation interactive du processus de stockage de données numériques sur de l'ADN synthétique, avec correction d'erreurs.
            </p>
        </header>

        <!-- Section d'information sur le stockage ADN -->
        <section class="mb-20">
            <h2 class="text-3xl font-bold text-white mb-12 text-center">Le Stockage sur ADN : Une Révolution</h2>
            
            <div class="max-w-7xl mx-auto">
                <h3 class="text-2xl font-semibold text-sky-300 mb-8 text-center">Le Processus Physique en 4 Étapes Clés</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                    <!-- Étape 1: Synthèse -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 6a1.5 1.5 0 11-3 0m3 0a1.5 1.5 0 10-3 0M3.75 6H7.5m3 12h9.75m-9.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-3.75 0H7.5m9-6h3.75m-3.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-9.75 0h9.75" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">1. Synthèse (Écriture)</h4>
                        <p class="text-gray-400 text-sm">C'est le processus d'écriture. Les données binaires (0 et 1) sont converties en une séquence de bases d'ADN (A, C, G, T). Une machine, tel un "imprimeur d'ADN", assemble chimiquement des brins d'ADN synthétique, base par base, pour correspondre à cette séquence.</p>
                    </div>

                    <!-- Étape 2: Stockage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">2. Stockage (Archivage)</h4>
                        <p class="text-gray-400 text-sm">Pour une conservation à très long terme, les molécules d'ADN synthétisées sont déshydratées et encapsulées dans des petites billes de silice. Cet "archivage moléculaire" les protège de la dégradation et permet de conserver les données durant des millénaires sans apport d'énergie.</p>
                    </div>

                    <!-- Étape 3: Séquençage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">3. Séquençage (Lecture)</h4>
                        <p class="text-gray-400 text-sm">C'est le processus de lecture. Les capsules d'ADN sont réhydratées et insérées dans un séquenceur. Cette machine lit l'ordre des bases (A, C, G, T) sur des millions de brins en parallèle, générant de multiples copies ("lectures") de la séquence originale, souvent avec quelques erreurs.</p>
                    </div>

                    <!-- Étape 4: Décodage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">4. Décodage (Interprétation)</h4>
                        <p class="text-gray-400 text-sm">C'est l'étape logicielle finale. Les multiples lectures bruitées sont analysées par des algorithmes (comme notre consensus et la correction LDPC) pour reconstruire la séquence d'ADN parfaite. Celle-ci est ensuite reconvertie en données binaires pour restaurer le fichier original à l'identique.</p>
                    </div>
                </div>
            </div>

            <h3 class="text-2xl font-semibold text-sky-300 mb-4 text-center mt-20">Avantages et Défis</h3>
            <div class="flex flex-col md:flex-row justify-center gap-8 max-w-5xl mx-auto">
                <div class="pipeline-card p-6 rounded-lg text-left flex-1">
                    <h4 class="text-xl font-semibold mb-3 neon-text">Avantages</h4>
                    <ul class="space-y-2 text-gray-300 text-sm">
                        <li class="flex items-start">
                            <span class="text-sky-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Densité extrême :</strong> Un gramme d'ADN peut théoriquement stocker plus de 200 pétaoctets de données, l'équivalent de millions de films en haute définition.</div>
                        </li>
                        <li class="flex items-start">
                            <span class="text-sky-400 font-bold mr-2">&#10140;</span>
                             <div><strong class="font-semibold text-white">Durabilité Millénaire :</strong> Conservé dans de bonnes conditions (froid, sec, à l'abri de la lumière), l'ADN peut préserver l'information pendant des milliers d'années sans dégradation.</div>
                        </li>
                    </ul>
                </div>
                 <div class="pipeline-card p-6 rounded-lg text-left flex-1">
                    <h4 class="text-xl font-semibold mb-3 neon-text">Défis Actuels</h4>
                    <ul class="space-y-2 text-gray-300 text-sm">
                        <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Coût :</strong> La synthèse et le séquençage de l'ADN sont encore des processus très coûteux, bien que les prix diminuent rapidement.</div>
                        </li>
                        <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Vitesse :</strong> L'écriture et la lecture des données sur ADN sont beaucoup plus lentes que les technologies de stockage traditionnelles. Ce n'est pas une technologie d'accès rapide.</div>
                        </li>
                         <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Taux d'erreur :</strong> Les processus chimiques peuvent introduire des erreurs (mutations). Des algorithmes de correction robustes, comme celui simulé ici, sont donc essentiels.</div>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- Bouton GitHub -->
            <div class="text-center mt-12">
                <a href="https://github.com/TeodoreAutuly/DNA-Storage-Pipeline" target="_blank" rel="noopener noreferrer"
                   class="inline-flex items-center gap-x-2 bg-sky-600 text-white font-semibold px-6 py-3 rounded-lg btn-neon">
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                      <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    Voir le Projet sur GitHub
                </a>
            </div>

        </section>


        <!-- Simulateur -->
        <main class="pipeline-card p-6 sm:p-8 rounded-lg">
            <h2 class="text-3xl font-bold text-white mb-8 text-center">Simulateur de Pipeline</h2>
            
            <!-- Controles -->
            <div class="mb-10 space-y-6 max-w-5xl mx-auto">
                <div>
                    <label for="inputText" class="block text-sm font-medium text-sky-300 mb-2">1. Entrez une phrase à stocker :</label>
                    <input type="text" id="inputText" class="w-full bg-slate-800 border border-slate-600 rounded-md py-2 px-3 text-white focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" value="Bonjour le monde !">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div>
                        <label for="ldpcRatio" class="block text-sm font-medium text-sky-300 mb-2">2. Ratio d'information LDPC : <span id="ldpcRatioValue" class="font-mono text-sky-400">0.7</span></label>
                        <input type="range" id="ldpcRatio" min="0.5" max="0.9" step="0.1" value="0.7" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Robuste</span>
                            <span>Dense</span>
                        </div>
                    </div>
                    <div>
                        <label for="readCount" class="block text-sm font-medium text-sky-300 mb-2">3. Nombre de lectures ADN : <span id="readCountValue" class="font-mono text-sky-400">20</span></label>
                        <input type="range" id="readCount" min="5" max="50" step="5" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                         <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Moins</span>
                            <span>Plus</span>
                        </div>
                    </div>
                    <div>
                        <label for="errorRate" class="block text-sm font-medium text-sky-300 mb-2">4. Taux d'erreur du canal : <span id="errorRateValue" class="font-mono text-sky-400">5%</span></label>
                        <input type="range" id="errorRate" min="1" max="10" step="1" value="5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Faible</span>
                            <span>Élevé</span>
                        </div>
                    </div>
                </div>

                <div class="text-center pt-4">
                    <button id="simulateBtn" class="bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-8 rounded-lg transition duration-300 transform hover:scale-105 w-60 h-12 flex items-center justify-center">
                        <span id="btnText">Lancer la Simulation</span>
                        <svg id="btnSpinner" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Résultats de la simulation -->
            <div id="simulationResults" class="mt-12 space-y-8">
                <!-- Cette section sera remplie par le JavaScript -->
            </div>
        </main>
        
        <footer class="text-center mt-20 text-gray-500 text-sm">
            <p>Réalisé par Téodore Autuly pour un projet supervisé par Elsa Dupraz.</p>
             <p class="mt-4">MIT License</p>
        </footer>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- ELEMENTS DU DOM ---
            const runButton = document.getElementById('runSimulation');
            const resultsContainer = document.getElementById('simulation-results');
            const inputText = document.getElementById('inputText');
            
            const ldpcRateSlider = document.getElementById('ldpcRate');
            const ldpcRateValue = document.getElementById('ldpcRateValue');
            const readsCountSlider = document.getElementById('readsCount');
            const readsCountValue = document.getElementById('readsCountValue');
            const errorRateSlider = document.getElementById('errorRate');
            const errorRateValue = document.getElementById('errorRateValue');

            // --- LISTENERS POUR AFFICHER LES VALEURS DES SLIDERS ---
            ldpcRateSlider.addEventListener('input', () => {
                ldpcRateValue.textContent = parseFloat(ldpcRateSlider.value).toFixed(1);
            });
            readsCountSlider.addEventListener('input', () => {
                readsCountValue.textContent = readsCountSlider.value;
            });
            errorRateSlider.addEventListener('input', () => {
                errorRateValue.textContent = `${(100 - errorRateSlider.value)}%`;
            });


            // --- FONCTIONS DU PIPELINE ---

            // Convertit un texte en chaîne binaire (ex: 'A' -> '01000001')
            const textToBinary = (text) => text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');

            // Classe simplifiée pour simuler l'encodage et le décodage LDPC
            class LdpcSimulator {
                constructor(k, rate) {
                    this.k = k; // Longueur du message
                    this.rate = rate;
                    this.n = Math.ceil(k / rate); // Longueur du mot de code
                    this.m = this.n - this.k; // Nombre de bits de parité
                }

                encode(message) {
                    // Simulation: ajoute des bits de parité (simple répétition pour la démo)
                    const parity = message.slice(0, this.m);
                    return message + parity;
                }

                decode(received, quality) {
                    const messagePart = received.slice(0, this.k);
                    let correctedMessage = messagePart.split('');
                    const originalMessage = textToBinary(inputText.value);

                    // Simule la correction d'erreurs: plus la qualité est haute, plus on corrige
                    const correctionPower = quality / 100;
                    let errorsCorrected = 0;
                    
                    for (let i = 0; i < this.k; i++) {
                        if (correctedMessage[i] !== originalMessage[i]) {
                            if (Math.random() < correctionPower) {
                                correctedMessage[i] = originalMessage[i];
                                errorsCorrected++;
                            }
                        }
                    }
                    console.log(`LDPC Correction: Attempted to fix ${errorsCorrected} bits.`);
                    return correctedMessage.join('');
                }
            }
            
            // Convertit une chaîne binaire en séquence ADN (ex: '00' -> 'A')
            const binaryToDna = (binary) => {
                const dnaMap = {'00': 'A', '01': 'C', '10': 'G', '11': 'T'};
                let dna = '';
                // Assure une longueur paire
                const binaryPadded = binary.length % 2 !== 0 ? binary + '0' : binary;
                for (let i = 0; i < binaryPadded.length; i += 2) {
                    dna += dnaMap[binaryPadded.substring(i, i + 2)];
                }
                return dna;
            };

            // Simule le canal bruité (erreurs de synthèse, stockage, séquençage)
            const simulateNoisyChannel = (dna, quality, readsCount) => {
                const errorRate = (100 - quality) / 750; // Taux d'erreur jusqu'à ~13%
                const reads = [];
                for (let i = 0; i < readsCount; i++) {
                    let read = dna.split('');
                    for (let j = 0; j < read.length; j++) {
                        if (Math.random() < errorRate) {
                            const errorType = Math.random();
                            const bases = ['A', 'C', 'G', 'T'];
                            if (errorType < 0.7) { // Substitution
                                read[j] = bases[Math.floor(Math.random() * 4)];
                            } else if (errorType < 0.85) { // Délétion
                                read[j] = '';
                            } else { // Insertion
                                read[j] += bases[Math.floor(Math.random() * 4)];
                            }
                        }
                    }
                    reads.push(read.join(''));
                }
                return reads;
            };

            // Construit une séquence consensus à partir des lectures bruitées
            const buildConsensus = (reads) => {
                if (!reads || reads.length === 0) return "";
                const maxLength = Math.max(...reads.map(r => r.length));
                let consensus = '';
                for (let i = 0; i < maxLength; i++) {
                    const counts = { 'A': 0, 'C': 0, 'G': 0, 'T': 0 };
                    let validBases = 0;
                    reads.forEach(read => {
                        if (i < read.length && counts.hasOwnProperty(read[i])) {
                            counts[read[i]]++;
                            validBases++;
                        }
                    });
                    if (validBases > 0) {
                        const mostCommonBase = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                        consensus += mostCommonBase;
                    }
                }
                return consensus;
            };

            // Convertit une séquence ADN en chaîne binaire et la synchronise à la bonne longueur
            const dnaToBinaryAndSync = (dna, expectedLength) => {
                const binaryMap = {'A': '00', 'C': '01', 'G': '10', 'T': '11'};
                let binary = dna.split('').map(base => binaryMap[base] || '').join('');

                // Synchronisation: couper ou compléter pour atteindre la longueur attendue
                if (binary.length > expectedLength) {
                    binary = binary.slice(0, expectedLength);
                } else if (binary.length < expectedLength) {
                    binary = binary.padEnd(expectedLength, '0');
                }
                return binary;
            };

            const binaryToText = (binary) => {
                let text = '';
                for (let i = 0; i < binary.length; i += 8) {
                    const byte = binary.substring(i, i + 8);
                    if (byte.length === 8) {
                        text += String.fromCharCode(parseInt(byte, 2));
                    }
                }
                return text;
            };

            // --- FONCTION D'AFFICHAGE ---
            let stepCounter = 1;
            const renderStep = (title, description, data) => {
                const truncatedData = data.length > 200 ? data.substring(0, 200) + '...' : data;
                const html = `
                    <div class="result-card bg-gray-900/50 p-4 rounded-lg">
                        <h4 class="font-semibold text-sky-400">Étape ${stepCounter++}: ${title}</h4>
                        <p class="text-sm text-gray-400 mb-2">${description}</p>
                        <p class="code-block text-xs">${truncatedData}</p>
                    </div>
                `;
                resultsContainer.innerHTML += html;
            };

            // --- LOGIQUE PRINCIPALE DE LA SIMULATION ---
            runButton.addEventListener('click', () => {
                const originalText = inputText.value;
                if (!originalText) {
                    alert("Veuillez entrer un message.");
                    return;
                }
                
                // Récupération des valeurs des sliders
                const ldpcRate = parseFloat(ldpcRateSlider.value);
                const readsCount = parseInt(readsCountSlider.value);
                const quality = parseInt(errorRateSlider.value);

                resultsContainer.innerHTML = '';
                stepCounter = 1;

                // --- DÉROULEMENT DU PIPELINE ---
                
                // 1. Encodage Binaire
                const binaryText = textToBinary(originalText);
                renderStep("Encodage Binaire", `Le message est converti en une suite de 0 et de 1 (longueur: ${binaryText.length} bits).`, binaryText);
                
                // 2. Code LDPC
                const ldpc = new LdpcSimulator(binaryText.length, ldpcRate);
                const codeword = ldpc.encode(binaryText);
                renderStep("Protection par Code LDPC", `Ratio: ${ldpcRate}. Des bits de parité sont ajoutés (nouvelle longueur: ${codeword.length} bits).`, codeword);

                // 3. Conversion en Séquence ADN
                const dnaSequence = binaryToDna(codeword);
                renderStep("Encodage en Séquence ADN", `La chaîne binaire est traduite en bases A, C, G, T (longueur: ${dnaSequence.length} bases).`, dnaSequence);
                
                // 4. Canal Bruité
                const noisyReads = simulateNoisyChannel(dnaSequence, quality, readsCount);
                const errorPercentage = ((100-quality)/7.5).toFixed(1);
                renderStep("Simulation du Canal Bruité", `Taux d'erreur: ~${errorPercentage}%. ${noisyReads.length} lectures imparfaites sont générées.`, noisyReads[0] || "[Échec de lecture]");

                // 5. Algorithme de Consensus
                const consensusDna = buildConsensus(noisyReads);
                renderStep("Algorithme de Consensus", `Les lectures sont alignées pour voter et reconstruire la séquence la plus probable (longueur: ${consensusDna.length} bases).`, consensusDna);

                // 6. Décodage et Synchronisation
                const syncedBinary = dnaToBinaryAndSync(consensusDna, codeword.length);
                renderStep("Décodage Binaire et Synchronisation", `La séquence consensus est reconvertie en binaire et ajustée à la longueur attendue (${syncedBinary.length} bits).`, syncedBinary);
                
                // 7. Correction d'Erreurs LDPC
                const correctedBinary = ldpc.decode(syncedBinary, quality);
                renderStep("Correction d'Erreurs LDPC", "Le code LDPC utilise les bits de parité pour tenter de corriger les erreurs restantes.", correctedBinary);

                // 8. Restitution du message et Résultats
                const decodedText = binaryToText(correctedBinary);
                const success = originalText === decodedText;

                const finalHtml = `
                    <div class="result-card bg-gray-900/50 p-6 rounded-lg mt-4">
                        <h3 class="text-xl font-bold text-white text-center">Résultat Final</h3>
                        <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                            <div>
                                <h4 class="font-semibold text-gray-400">Message Original:</h4>
                                <p class="code-block text-base mt-1">${originalText}</p>
                            </div>
                            <div>
                                <h4 class="font-semibold text-gray-400">Message Décodé:</h4>
                                <p class="code-block text-base mt-1 ${success ? 'text-green-400' : 'text-red-400'}">${decodedText || "Échec"}</p>
                            </div>
                        </div>
                        <div class="text-center pt-4 mt-4">
                            <p class="text-lg font-bold ${success ? 'text-green-400' : 'text-red-400'}">
                            ${success ? '✅ Succès de la transmission !' : '❌ Erreurs détectées dans le message final !'}
                            </p>
                        </div>
                    </div>
                `;
                resultsContainer.innerHTML += finalHtml;
            });
        });
    </script>
</body>
</html>
