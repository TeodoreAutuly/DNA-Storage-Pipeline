<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Storage Pipeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* slate-900 */
        }
        .orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .pipeline-card {
            background-color: rgba(30, 41, 59, 0.5); /* slate-800 with opacity */
            border: 1px solid rgba(51, 65, 85, 0.7); /* slate-700 with opacity */
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .pipeline-card:hover {
            border-color: rgba(56, 189, 248, 0.5); /* sky-400 with opacity */
        }
        .step-output {
            background-color: #1e293b; /* slate-800 */
            border: 1px solid #334155; /* slate-700 */
        }
        .neon-text {
            color: #7dd3fc; /* sky-300 */
            text-shadow: 0 0 5px rgba(14, 165, 233, 0.7), 
                         0 0 10px rgba(14, 165, 233, 0.7), 
                         0 0 20px rgba(14, 165, 233, 0.5);
        }
        .btn-neon {
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(14, 165, 233, 0.6), 0 0 10px rgba(14, 165, 233, 0.4);
        }
        .btn-neon:hover {
            box-shadow: 0 0 10px rgba(14, 165, 233, 1), 0 0 20px rgba(14, 165, 233, 0.8), 0 0 30px rgba(14, 165, 233, 0.6);
            transform: translateY(-2px);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.8s ease-out forwards;
        }
        .fade-in-delay-1 { animation-delay: 0.2s; }
        .fade-in-delay-2 { animation-delay: 0.4s; }
        .fade-in-delay-3 { animation-delay: 0.6s; }
        .fade-in-delay-4 { animation-delay: 0.8s; }
        .fade-in-delay-5 { animation-delay: 1.0s; }
    </style>
</head>
<body class="bg-slate-900 text-gray-200">
    <div class="container mx-auto px-4 py-12 md:py-20">
        <header class="text-center mb-20">
            <h1 class="orbitron text-4xl md:text-6xl font-bold text-white mb-4">
                DNA Storage Pipeline
            </h1>
            <p class="text-lg md:text-xl text-sky-300 max-w-3xl mx-auto">
                Une simulation interactive du processus de stockage de données numériques sur de l'ADN synthétique, avec correction d'erreurs.
            </p>
        </header>

        <!-- Section d'information sur le stockage ADN -->
        <section class="mb-20">
            <h2 class="text-3xl font-bold text-white mb-12 text-center">Le Stockage sur ADN : Une Révolution</h2>
            
            <div class="max-w-7xl mx-auto">
                <h3 class="text-2xl font-semibold text-sky-300 mb-8 text-center">Le Processus Physique en 4 Étapes Clés</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                    <!-- Étape 1: Synthèse -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 6a1.5 1.5 0 11-3 0m3 0a1.5 1.5 0 10-3 0M3.75 6H7.5m3 12h9.75m-9.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-3.75 0H7.5m9-6h3.75m-3.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-9.75 0h9.75" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">1. Synthèse (Écriture)</h4>
                        <p class="text-gray-400 text-sm">C'est le processus d'écriture. Les données binaires (0 et 1) sont converties en une séquence de bases d'ADN (A, C, G, T). Une machine, tel un "imprimeur d'ADN", assemble chimiquement des brins d'ADN synthétique, base par base, pour correspondre à cette séquence.</p>
                    </div>

                    <!-- Étape 2: Stockage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">2. Stockage (Archivage)</h4>
                        <p class="text-gray-400 text-sm">Pour une conservation à très long terme, les molécules d'ADN synthétisées sont déshydratées et encapsulées dans des petites billes de silice. Cet "archivage moléculaire" les protège de la dégradation et permet de conserver les données durant des millénaires sans apport d'énergie.</p>
                    </div>

                    <!-- Étape 3: Séquençage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">3. Séquençage (Lecture)</h4>
                        <p class="text-gray-400 text-sm">C'est le processus de lecture. Les capsules d'ADN sont réhydratées et insérées dans un séquenceur. Cette machine lit l'ordre des bases (A, C, G, T) sur des millions de brins en parallèle, générant de multiples copies ("lectures") de la séquence originale, souvent avec quelques erreurs.</p>
                    </div>

                    <!-- Étape 4: Décodage -->
                    <div class="pipeline-card p-6 rounded-lg flex flex-col items-center text-center hover:transform hover:-translate-y-2 hover:shadow-2xl hover:shadow-sky-500/20">
                        <div class="bg-sky-900/50 p-4 rounded-full mb-4">
                            <svg class="w-8 h-8 text-sky-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5" />
                            </svg>
                        </div>
                        <h4 class="text-xl font-semibold text-white mb-2">4. Décodage (Interprétation)</h4>
                        <p class="text-gray-400 text-sm">C'est l'étape logicielle finale. Les multiples lectures bruitées sont analysées par des algorithmes (comme notre consensus et la correction LDPC) pour reconstruire la séquence d'ADN parfaite. Celle-ci est ensuite reconvertie en données binaires pour restaurer le fichier original à l'identique.</p>
                    </div>
                </div>
            </div>

            <h3 class="text-2xl font-semibold text-sky-300 mb-4 text-center mt-20">Avantages et Défis</h3>
            <div class="flex flex-col md:flex-row justify-center gap-8 max-w-5xl mx-auto">
                <div class="pipeline-card p-6 rounded-lg text-left flex-1">
                    <h4 class="text-xl font-semibold mb-3 neon-text">Avantages</h4>
                    <ul class="space-y-2 text-gray-300 text-sm">
                        <li class="flex items-start">
                            <span class="text-sky-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Densité extrême :</strong> Un gramme d'ADN peut théoriquement stocker plus de 200 pétaoctets de données, l'équivalent de millions de films en haute définition.</div>
                        </li>
                        <li class="flex items-start">
                            <span class="text-sky-400 font-bold mr-2">&#10140;</span>
                             <div><strong class="font-semibold text-white">Durabilité Millénaire :</strong> Conservé dans de bonnes conditions (froid, sec, à l'abri de la lumière), l'ADN peut préserver l'information pendant des milliers d'années sans dégradation.</div>
                        </li>
                    </ul>
                </div>
                 <div class="pipeline-card p-6 rounded-lg text-left flex-1">
                    <h4 class="text-xl font-semibold mb-3 neon-text">Défis Actuels</h4>
                    <ul class="space-y-2 text-gray-300 text-sm">
                        <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Coût :</strong> La synthèse et le séquençage de l'ADN sont encore des processus très coûteux, bien que les prix diminuent rapidement.</div>
                        </li>
                        <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Vitesse :</strong> L'écriture et la lecture des données sur ADN sont beaucoup plus lentes que les technologies de stockage traditionnelles. Ce n'est pas une technologie d'accès rapide.</div>
                        </li>
                         <li class="flex items-start">
                            <span class="text-red-400 font-bold mr-2">&#10140;</span>
                            <div><strong class="font-semibold text-white">Taux d'erreur :</strong> Les processus chimiques peuvent introduire des erreurs (mutations). Des algorithmes de correction robustes, comme celui simulé ici, sont donc essentiels.</div>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- Bouton GitHub -->
            <div class="text-center mt-12">
                <a href="https://github.com/TeodoreAutuly/DNA-Storage-Pipeline" target="_blank" rel="noopener noreferrer"
                   class="inline-flex items-center gap-x-2 bg-sky-600 text-white font-semibold px-6 py-3 rounded-lg btn-neon">
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                      <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    Voir le Projet sur GitHub
                </a>
            </div>

        </section>


        <!-- Simulateur -->
        <main class="pipeline-card p-6 sm:p-8 rounded-lg">
            <h2 class="text-3xl font-bold text-white mb-8 text-center">Simulateur de Pipeline</h2>
            
            <!-- Controles -->
            <div class="mb-10 space-y-6 max-w-5xl mx-auto">
                <div>
                    <label for="inputText" class="block text-sm font-medium text-sky-300 mb-2">1. Entrez une phrase à stocker :</label>
                    <input type="text" id="inputText" class="w-full bg-slate-800 border border-slate-600 rounded-md py-2 px-3 text-white focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition" value="Bonjour le monde !">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div>
                        <label for="ldpcRatio" class="block text-sm font-medium text-sky-300 mb-2">2. Ratio d'information LDPC : <span id="ldpcRatioValue" class="font-mono text-sky-400">0.7</span></label>
                        <input type="range" id="ldpcRatio" min="0.5" max="0.9" step="0.1" value="0.7" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Robuste</span>
                            <span>Dense</span>
                        </div>
                    </div>
                    <div>
                        <label for="readCount" class="block text-sm font-medium text-sky-300 mb-2">3. Nombre de lectures ADN : <span id="readCountValue" class="font-mono text-sky-400">20</span></label>
                        <input type="range" id="readCount" min="5" max="50" step="5" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                         <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Moins</span>
                            <span>Plus</span>
                        </div>
                    </div>
                    <div>
                        <label for="errorRate" class="block text-sm font-medium text-sky-300 mb-2">4. Taux d'erreur du canal : <span id="errorRateValue" class="font-mono text-sky-400">5%</span></label>
                        <input type="range" id="errorRate" min="1" max="10" step="1" value="5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 flex justify-between mt-1">
                            <span>Faible</span>
                            <span>Élevé</span>
                        </div>
                    </div>
                </div>

                <div class="text-center pt-4">
                    <button id="simulateBtn" class="bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-8 rounded-lg transition duration-300 transform hover:scale-105 w-60 h-12 flex items-center justify-center">
                        <span id="btnText">Lancer la Simulation</span>
                        <svg id="btnSpinner" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Résultats de la simulation -->
            <div id="simulationResults" class="mt-12 space-y-8">
                <!-- Cette section sera remplie par le JavaScript -->
            </div>
        </main>
        
        <footer class="text-center mt-20 text-gray-500 text-sm">
            <p>Réalisé par Téodore Autuly pour un projet supervisé par Elsa Dupraz.</p>
             <p class="mt-4">MIT License</p>
        </footer>

    </div>

    <script>
        // DOM Elements
        const simulateBtn = document.getElementById('simulateBtn');
        const inputText = document.getElementById('inputText');
        const ldpcRatioSlider = document.getElementById('ldpcRatio');
        const readCountSlider = document.getElementById('readCount');
        const errorRateSlider = document.getElementById('errorRate');
        const ldpcRatioValue = document.getElementById('ldpcRatioValue');
        const readCountValue = document.getElementById('readCountValue');
        const errorRateValue = document.getElementById('errorRateValue');
        const simulationResults = document.getElementById('simulationResults');
        const btnText = document.getElementById('btnText');
        const btnSpinner = document.getElementById('btnSpinner');

        // Update slider value displays
        ldpcRatioSlider.addEventListener('input', () => ldpcRatioValue.textContent = parseFloat(ldpcRatioSlider.value).toFixed(1));
        readCountSlider.addEventListener('input', () => readCountValue.textContent = readCountSlider.value);
        errorRateSlider.addEventListener('input', () => errorRateValue.textContent = errorRateSlider.value + '%');
        
        // --- Fonctions de simulation basées sur le notebook ---
        
        function textToBinary(text) {
            return text.split('').map(char => {
                const binary = char.charCodeAt(0).toString(2);
                return '0'.repeat(8 - binary.length) + binary;
            }).join('');
        }

        function binaryToText(binary) {
            let text = '';
            for (let i = 0; i < binary.length; i += 8) {
                const byte = binary.substr(i, 8);
                if(byte.length === 8) {
                    text += String.fromCharCode(parseInt(byte, 2));
                }
            }
            return text;
        }
        
        function binaryToDna(binary) {
            const dnaMap = ['A', 'C', 'G', 'T'];
            let dna = '';
            if (binary.length % 2 !== 0) binary += '0';
            for (let i = 0; i < binary.length; i += 2) {
                const pair = binary.substr(i, 2);
                const index = parseInt(pair, 2);
                dna += dnaMap[index];
            }
            return dna;
        }

        function dnaToBinary(dna) {
            const binaryMap = { 'A': '00', 'C': '01', 'G': '10', 'T': '11', '-':'' };
            return dna.split('').map(base => binaryMap[base] || '').join('');
        }
        
        function ldpcEncode(binary, ratio) {
            const messageLength = binary.length;
            const parityLength = Math.round(messageLength * (1 - ratio) / ratio);
            let parity = '';
            for (let i = 0; i < parityLength; i++) {
                let bit = 0;
                for (let j = i; j < messageLength; j += parityLength) {
                    bit ^= parseInt(binary[j], 10);
                }
                parity += bit;
            }
            return binary + parity;
        }

        function ldpcDecode(codeword, originalMessageLength) {
            return codeword.substring(0, originalMessageLength);
        }

        function noisyChannel(dnaSequence, readCount, errorRate) {
            const reads = [];
            for (let i = 0; i < readCount; i++) {
                let read = '';
                for (const base of dnaSequence) {
                    const rand = Math.random();
                    if (rand < errorRate / 2) {
                        continue; // Deletion
                    } else if (rand < errorRate) {
                        const bases = 'ACGT'; // Substitution
                        read += bases[Math.floor(Math.random() * 4)];
                    } else {
                        read += base;
                    }
                    if (Math.random() < errorRate / 5) { // Insertion
                        const bases = 'ACGT';
                        read += bases[Math.floor(Math.random() * 4)];
                    }
                }
                reads.push(read);
            }
            return reads;
        }

        function consensusAlgorithm(reads) {
            if (reads.length === 0) return '';
            const lengths = reads.map(r => r.length).sort((a,b) => a-b);
            const consensusLength = lengths[Math.floor(lengths.length / 2)];
            
            let consensusSequence = '';
            for (let i = 0; i < consensusLength; i++) {
                const baseCounts = { A: 0, C: 0, G: 0, T: 0 };
                let validBases = 0;
                for (const read of reads) {
                    if (i < read.length) {
                        const base = read[i];
                        if (baseCounts.hasOwnProperty(base)) {
                            baseCounts[base]++;
                            validBases++;
                        }
                    }
                }
                if (validBases === 0) continue;
                let mostCommonBase = 'A', maxCount = 0;
                for (const base in baseCounts) {
                    if (baseCounts[base] > maxCount) {
                        maxCount = baseCounts[base];
                        mostCommonBase = base;
                    }
                }
                consensusSequence += mostCommonBase;
            }
            return consensusSequence;
        }

        function createStepCard(title, description, data, step) {
            const truncate = (str, len) => str.length > len ? str.substring(0, len) + '...' : str;
            return `
                <div class="pipeline-card p-4 rounded-lg opacity-0 fade-in fade-in-delay-${step}">
                    <h3 class="text-lg font-semibold text-sky-400 mb-2">${title}</h3>
                    <p class="text-sm text-gray-400 mb-3">${description}</p>
                    <div class="step-output p-3 rounded-md text-xs font-mono break-all text-gray-300">
                        ${truncate(data, 250)}
                    </div>
                </div>
            `;
        }

        function createResultCard(originalText, recoveredText) {
            const success = originalText === recoveredText;
            const bgColor = success ? 'bg-green-900/50 border-green-500/50' : 'bg-red-900/50 border-red-500/50';
            const title = success ? 'Succès de la Récupération' : 'Échec de la Récupération';
            const icon = success ? 
                `<svg class="w-16 h-16 text-green-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>` :
                `<svg class="w-16 h-16 text-red-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`;
            
            return `
                 <div class="pipeline-card p-6 rounded-lg ${bgColor} opacity-0 fade-in fade-in-delay-5">
                    <div class="flex flex-col md:flex-row items-center gap-6">
                        <div class="flex-shrink-0">${icon}</div>
                        <div>
                            <h3 class="text-xl font-bold ${success ? 'text-green-300' : 'text-red-300'}">${title}</h3>
                            <p class="mt-2 text-gray-300"><strong class="font-semibold text-white">Original :</strong> ${originalText}</p>
                            <p class="mt-1 text-gray-300"><strong class="font-semibold text-white">Récupéré :</strong> ${recoveredText}</p>
                        </div>
                    </div>
                 </div>
            `;
        }

        simulateBtn.addEventListener('click', () => {
            simulationResults.innerHTML = '';
            simulateBtn.disabled = true;
            btnText.classList.add('hidden');
            btnSpinner.classList.remove('hidden');
            
            setTimeout(() => {
                const originalText = inputText.value;
                const ldpcRatio = parseFloat(ldpcRatioSlider.value);
                const readCount = parseInt(readCountSlider.value);
                const errorRate = parseInt(errorRateSlider.value) / 100;

                const originalBinary = textToBinary(originalText);
                const codewordBinary = ldpcEncode(originalBinary, ldpcRatio);
                simulationResults.innerHTML += createStepCard(
                    "Étape 1 : Encodage LDPC",
                    `La chaîne binaire est encodée. Des bits de redondance sont ajoutés pour la correction d'erreurs. Avec un ratio de ${ldpcRatio}, ${ldpcRatio*100}% de la séquence contient l'information utile.`,
                    codewordBinary, 1);

                const originalDna = binaryToDna(codewordBinary);
                simulationResults.innerHTML += createStepCard(
                    "Étape 2 : Conversion en Séquence ADN",
                    "Le mot de code binaire est converti en une séquence de bases ADN (A, C, G, T).",
                    originalDna, 2);
                
                const noisyReads = noisyChannel(originalDna, readCount, errorRate);
                const readsDisplay = noisyReads.slice(0, 5).join('<br>');
                simulationResults.innerHTML += createStepCard(
                    "Étape 3 : Canal Bruité (Simulation)",
                    `La séquence passe par un canal avec un taux d'erreur de ${errorRate*100}%. ${readCount} lectures imparfaites sont générées.`,
                    readsDisplay + (readCount > 5 ? '<br>...' : ''), 3);

                const consensusDna = consensusAlgorithm(noisyReads);
                simulationResults.innerHTML += createStepCard(
                    "Étape 4 : Algorithme de Consensus & Correction",
                    `Les ${readCount} lectures sont alignées pour reconstruire la séquence probable, corrigeant la majorité des erreurs.`,
                    consensusDna, 4);
                
                const finalBinary = dnaToBinary(consensusDna);
                const finalMessageBinary = ldpcDecode(finalBinary, originalBinary.length);
                const recoveredText = binaryToText(finalMessageBinary);

                simulationResults.innerHTML += createResultCard(originalText, recoveredText);

                simulateBtn.disabled = false;
                btnText.classList.remove('hidden');
                btnSpinner.classList.add('hidden');
            }, 100);
        });
    </script>
</body>
</html>
